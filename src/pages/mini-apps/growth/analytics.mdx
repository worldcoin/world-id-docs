import { Link } from '@/components/Link'

# Data & Analytics (Bare-Minimum Stack)

**Goal**: Track the metrics that matter most for growth—conversion funnels, retention cohorts, and viral loops—with minimal setup complexity.

You can't optimize what you don't measure. This section covers the essential analytics stack for indie developers: what to track, how to track it simply, and which metrics actually predict growth.

## Why You Need This

Most apps fail because they optimize for vanity metrics instead of growth drivers. Instagram doesn't care about page views—they care about daily active users and photos shared. Your mini app needs to track the events that predict long-term success, not just surface-level engagement.

## Core Events to Track

Focus on these events that form your growth funnel:

| Event                 | Why It Matters                    | When to Track           |
| --------------------- | --------------------------------- | ----------------------- |
| **app_open**          | Foundation metric; session starts | Every app launch        |
| **signup**            | Conversion from visitor to user   | Account creation        |
| **first_value**       | "Aha!" moment; predicts retention | First meaningful action |
| **invite_sent**       | Viral loop start                  | Share button clicked    |
| **invite_accepted**   | Viral loop completion             | New user from referral  |
| **notification_open** | Engagement via push               | Notification tapped     |
| **streak_day**        | Habit formation                   | Daily check-in          |
| **purchase**          | Monetization                      | Any payment             |

## Implementation Options

### Option 1: PostHog (Recommended for Startups)

Full product analytics with 1M free events/month and built-in funnels:

```typescript
// Install: npm install posthog-js
import { PostHog } from 'posthog-js'

const posthog = new PostHog('YOUR_API_KEY', {
	api_host: 'https://app.posthog.com',
})

// Track core events
function trackEvent(event: string, properties: Record<string, any>) {
	posthog.capture(event, {
		...properties,
		timestamp: new Date(),
		app_version: '1.0.0',
	})
}

// User identification
function identifyUser(userId: string, traits: Record<string, any>) {
	posthog.identify(userId, traits)
}

// Usage examples
trackEvent('app_open', { source: 'home_screen' })
trackEvent('signup', { method: 'world_id' })
trackEvent('first_value', { action: 'completed_puzzle' })
trackEvent('invite_sent', { method: 'share_button' })
```

### Option 2: Plausible (Lightweight Alternative)

Super simple, privacy-focused analytics:

```typescript
// Simple HTTP API tracking
async function trackEvent(event: string, properties: Record<string, any> = {}) {
	await fetch('https://plausible.io/api/event', {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			'User-Agent': navigator.userAgent,
		},
		body: JSON.stringify({
			name: event,
			url: window.location.href,
			domain: 'your-mini-app.com',
			props: properties,
		}),
	})
}

// Track with custom properties
trackEvent('invite_sent', {
	ref_code: 'abc123',
	channel: 'social_share',
})
```

### Option 3: Custom Event Collector (DIY)

Minimal backend for complete control:

```typescript
// Client-side event collector
class EventTracker {
	private events: Array<{
		event: string
		properties: Record<string, any>
		timestamp: Date
		userId?: string
	}> = []

	track(event: string, properties: Record<string, any> = {}) {
		this.events.push({
			event,
			properties,
			timestamp: new Date(),
			userId: this.getCurrentUserId(),
		})

		// Batch send events
		if (this.events.length >= 10) {
			this.flush()
		}
	}

	private async flush() {
		if (this.events.length === 0) return

		const batch = [...this.events]
		this.events = []

		try {
			await fetch('/api/analytics/events', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ events: batch }),
			})
		} catch (error) {
			// Re-queue events on failure
			this.events.unshift(...batch)
		}
	}

	private getCurrentUserId(): string | undefined {
		// Your user identification logic
		return localStorage.getItem('user_id') || undefined
	}
}

// Usage
const tracker = new EventTracker()
tracker.track('app_open', { source: 'notification' })
tracker.track('streak_day', { day_count: 7 })
```

## Essential Metrics Dashboard

Create a simple dashboard that tracks the metrics that matter:

### 1. Conversion Funnel

Track how users progress through your core flow:

```typescript
interface FunnelMetrics {
	step: string
	users: number
	conversion_rate: number
}

async function getFunnelMetrics(days: number = 30): Promise<FunnelMetrics[]> {
	const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000)

	const appOpens = await countUniqueUsers('app_open', since)
	const signups = await countUniqueUsers('signup', since)
	const firstValue = await countUniqueUsers('first_value', since)
	const inviteSent = await countUniqueUsers('invite_sent', since)

	return [
		{ step: 'App Open', users: appOpens, conversion_rate: 100 },
		{ step: 'Signup', users: signups, conversion_rate: (signups / appOpens) * 100 },
		{ step: 'First Value', users: firstValue, conversion_rate: (firstValue / signups) * 100 },
		{ step: 'Invite Sent', users: inviteSent, conversion_rate: (inviteSent / firstValue) * 100 },
	]
}
```

### 2. Retention Cohorts

The most important metric for sustainable growth:

```typescript
interface RetentionCohort {
	cohort_date: string
	cohort_size: number
	day_1: number
	day_7: number
	day_30: number
}

async function getRetentionCohorts(): Promise<RetentionCohort[]> {
	// Group users by signup date
	const cohorts = await db.query(`
    SELECT 
      DATE(created_at) as cohort_date,
      COUNT(*) as cohort_size
    FROM users 
    WHERE created_at >= DATE_SUB(NOW(), INTERVAL 60 DAY)
    GROUP BY DATE(created_at)
    ORDER BY cohort_date DESC
  `)

	const results: RetentionCohort[] = []

	for (const cohort of cohorts) {
		const day1 = await getRetentionForCohort(cohort.cohort_date, 1)
		const day7 = await getRetentionForCohort(cohort.cohort_date, 7)
		const day30 = await getRetentionForCohort(cohort.cohort_date, 30)

		results.push({
			cohort_date: cohort.cohort_date,
			cohort_size: cohort.cohort_size,
			day_1: (day1 / cohort.cohort_size) * 100,
			day_7: (day7 / cohort.cohort_size) * 100,
			day_30: (day30 / cohort.cohort_size) * 100,
		})
	}

	return results
}

async function getRetentionForCohort(cohortDate: string, days: number): Promise<number> {
	const targetDate = new Date(cohortDate)
	targetDate.setDate(targetDate.getDate() + days)

	return await db.query(
		`
    SELECT COUNT(DISTINCT user_id) as active_users
    FROM events 
    WHERE event = 'app_open' 
    AND DATE(timestamp) = ?
    AND user_id IN (
      SELECT id FROM users WHERE DATE(created_at) = ?
    )
  `,
		[targetDate.toISOString().split('T')[0], cohortDate]
	)
}
```

### 3. Viral Loop Metrics

Track how effectively users bring in new users:

```typescript
interface ViralMetrics {
	invites_sent: number
	invites_accepted: number
	k_factor: number
	cycle_time_hours: number
}

async function getViralMetrics(days: number = 30): Promise<ViralMetrics> {
	const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000)

	const invitesSent = await countEvents('invite_sent', since)
	const invitesAccepted = await countEvents('invite_accepted', since)
	const activeUsers = await countUniqueUsers('app_open', since)

	// K-factor: new users per existing user
	const kFactor = invitesAccepted / activeUsers

	// Cycle time: average time from invite sent to accepted
	const cycleTime = await db.query(
		`
    SELECT AVG(TIMESTAMPDIFF(HOUR, sent.timestamp, accepted.timestamp)) as avg_hours
    FROM events sent
    JOIN events accepted ON sent.properties->>'$.ref_code' = accepted.properties->>'$.ref_code'
    WHERE sent.event = 'invite_sent' 
    AND accepted.event = 'invite_accepted'
    AND sent.timestamp >= ?
  `,
		[since]
	)

	return {
		invites_sent: invitesSent,
		invites_accepted: invitesAccepted,
		k_factor: kFactor,
		cycle_time_hours: cycleTime[0]?.avg_hours || 0,
	}
}
```

## Event Schema Best Practices

Keep your event structure consistent and queryable:

```typescript
interface BaseEvent {
	event: string
	user_id: string
	timestamp: Date
	properties: Record<string, any>
	session_id?: string
}

// Good event examples
const goodEvents = {
	app_open: {
		event: 'app_open',
		user_id: 'user123',
		timestamp: new Date(),
		properties: {
			source: 'home_screen', // or 'notification', 'deep_link'
			session_id: 'session456',
		},
	},

	invite_sent: {
		event: 'invite_sent',
		user_id: 'user123',
		timestamp: new Date(),
		properties: {
			ref_code: 'abc123',
			method: 'share_button', // or 'qr_code', 'link_copy'
			recipient_count: 1,
		},
	},

	gamification_action: {
		event: 'badge_earned',
		user_id: 'user123',
		timestamp: new Date(),
		properties: {
			badge_id: 'streak_7',
			badge_name: 'Week Warrior',
			is_first_badge: false,
		},
	},
}

// Avoid these patterns
const badEvents = {
	// Too generic
	button_click: { event: 'button_click', button_id: 'share' },

	// Missing context
	user_action: { event: 'user_action' },

	// Inconsistent naming
	userSignUp: { event: 'userSignUp' }, // Use snake_case

	// Nested objects in properties (hard to query)
	complex_event: {
		event: 'purchase',
		properties: {
			item: { id: 1, name: 'Premium', price: { amount: 10, currency: 'USD' } },
		},
	},
}
```

## Quick Dashboard Setup

Create a simple dashboard that shows your key metrics:

```typescript
// Dashboard component
function GrowthDashboard() {
	const [metrics, setMetrics] = useState({
		funnel: [],
		retention: [],
		viral: null,
		notifications: null,
	})

	useEffect(() => {
		async function loadMetrics() {
			const [funnel, retention, viral, notifications] = await Promise.all([
				getFunnelMetrics(30),
				getRetentionCohorts(),
				getViralMetrics(30),
				getNotificationMetrics(7),
			])

			setMetrics({ funnel, retention, viral, notifications })
		}

		loadMetrics()
	}, [])

	return (
		<div className="grid grid-cols-2 gap-6">
			{/* Funnel Chart */}
			<div className="bg-white p-6 rounded-lg shadow">
				<h3 className="text-lg font-bold mb-4">Conversion Funnel</h3>
				{metrics.funnel.map((step, index) => (
					<div key={step.step} className="mb-2">
						<div className="flex justify-between">
							<span>{step.step}</span>
							<span>
								{step.users} users ({step.conversion_rate.toFixed(1)}%)
							</span>
						</div>
						<div className="w-full bg-gray-200 rounded-full h-2">
							<div
								className="bg-blue-600 h-2 rounded-full"
								style={{ width: `${step.conversion_rate}%` }}
							/>
						</div>
					</div>
				))}
			</div>

			{/* Retention Table */}
			<div className="bg-white p-6 rounded-lg shadow">
				<h3 className="text-lg font-bold mb-4">Retention Cohorts</h3>
				<table className="w-full text-sm">
					<thead>
						<tr className="border-b">
							<th className="text-left">Cohort</th>
							<th className="text-right">Size</th>
							<th className="text-right">D1</th>
							<th className="text-right">D7</th>
							<th className="text-right">D30</th>
						</tr>
					</thead>
					<tbody>
						{metrics.retention.slice(0, 10).map(cohort => (
							<tr key={cohort.cohort_date} className="border-b">
								<td>{cohort.cohort_date}</td>
								<td className="text-right">{cohort.cohort_size}</td>
								<td className="text-right">{cohort.day_1.toFixed(1)}%</td>
								<td className="text-right">{cohort.day_7.toFixed(1)}%</td>
								<td className="text-right">{cohort.day_30.toFixed(1)}%</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			{/* Viral Metrics */}
			<div className="bg-white p-6 rounded-lg shadow">
				<h3 className="text-lg font-bold mb-4">Viral Loop</h3>
				{metrics.viral && (
					<div className="space-y-2">
						<div className="flex justify-between">
							<span>Invites Sent</span>
							<span className="font-bold">{metrics.viral.invites_sent}</span>
						</div>
						<div className="flex justify-between">
							<span>Invites Accepted</span>
							<span className="font-bold">{metrics.viral.invites_accepted}</span>
						</div>
						<div className="flex justify-between">
							<span>K-Factor</span>
							<span className="font-bold">{metrics.viral.k_factor.toFixed(2)}</span>
						</div>
						<div className="flex justify-between">
							<span>Cycle Time</span>
							<span className="font-bold">{metrics.viral.cycle_time_hours.toFixed(1)}h</span>
						</div>
					</div>
				)}
			</div>

			{/* Notification Performance */}
			<div className="bg-white p-6 rounded-lg shadow">
				<h3 className="text-lg font-bold mb-4">Notifications (7d)</h3>
				{metrics.notifications && (
					<div className="space-y-2">
						<div className="flex justify-between">
							<span>Open Rate</span>
							<span
								className={`font-bold ${
									metrics.notifications.open_rate >= 15
										? 'text-green-600'
										: metrics.notifications.open_rate >= 10
										? 'text-yellow-600'
										: 'text-red-600'
								}`}
							>
								{metrics.notifications.open_rate.toFixed(1)}%
							</span>
						</div>
						<div className="flex justify-between">
							<span>Badge Eligible</span>
							<span
								className={`font-bold ${
									metrics.notifications.open_rate >= 15 ? 'text-green-600' : 'text-red-600'
								}`}
							>
								{metrics.notifications.open_rate >= 15 ? 'Yes' : 'No'}
							</span>
						</div>
					</div>
				)}
			</div>
		</div>
	)
}
```

## A/B Testing Setup

Simple experimentation without complex infrastructure:

```typescript
interface Experiment {
	id: string
	name: string
	variants: string[]
	traffic_allocation: number // 0-1
}

class ABTester {
	private experiments: Map<string, Experiment> = new Map()

	createExperiment(experiment: Experiment) {
		this.experiments.set(experiment.id, experiment)
	}

	getVariant(experimentId: string, userId: string): string {
		const experiment = this.experiments.get(experimentId)
		if (!experiment) return 'control'

		// Consistent assignment based on user ID hash
		const hash = this.hashString(userId + experimentId)
		const bucket = hash % 100

		if (bucket < experiment.traffic_allocation * 100) {
			const variantIndex = hash % experiment.variants.length
			return experiment.variants[variantIndex]
		}

		return 'control'
	}

	private hashString(str: string): number {
		let hash = 0
		for (let i = 0; i < str.length; i++) {
			const char = str.charCodeAt(i)
			hash = (hash << 5) - hash + char
			hash = hash & hash // Convert to 32-bit integer
		}
		return Math.abs(hash)
	}
}

// Usage
const abTester = new ABTester()

abTester.createExperiment({
	id: 'invite_button_copy',
	name: 'Invite Button Copy Test',
	variants: ['invite_friends', 'share_earn_rewards'],
	traffic_allocation: 0.5, // 50% of users
})

// In your component
function InviteButton({ userId }: { userId: string }) {
	const variant = abTester.getVariant('invite_button_copy', userId)

	const buttonText = variant === 'share_earn_rewards' ? 'Share & Earn Rewards' : 'Invite Friends'

	const handleClick = () => {
		// Track which variant was clicked
		trackEvent('invite_button_clicked', {
			variant,
			experiment_id: 'invite_button_copy',
		})

		// Your invite logic
		showInviteModal()
	}

	return <button onClick={handleClick}>{buttonText}</button>
}
```

## What to Optimize First

Focus on these metrics in order of impact:

1. **Conversion to First Value** - If users don't experience value, nothing else matters
2. **Day 1 Retention** - Shows product-market fit
3. **Day 7 Retention** - Shows habit formation
4. **Invite Acceptance Rate** - Drives organic growth
5. **Notification Open Rate** - Enables re-engagement

## Common Analytics Mistakes

Avoid these pitfalls:

1. **Tracking too many events** - Start with 5-8 core events
2. **Vanity metrics** - Page views don't predict success
3. **No cohort analysis** - Averages hide declining retention
4. **Ignoring retention** - Growth without retention is expensive
5. **Over-segmentation** - Wait until you have 1000+ users

## Next Steps

1. **Choose your analytics tool** (PostHog recommended for most teams)
2. **Implement core event tracking** for your key user actions
3. **Set up retention cohort analysis** to measure product-market fit
4. **Create a simple dashboard** showing funnel, retention, and viral metrics
5. **Start with one A/B test** on your most important conversion point

Remember: The goal isn't to track everything—it's to track the events that predict long-term success and help you make better product decisions.

<Link href="/mini-apps/growth">← Back to Growth Playbook</Link>{' '}
